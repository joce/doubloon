<!-- Generated by SpecStory -->

# Sync textual clock with OS time (2025-07-05 22:44Z)

_**User**_

How can I make my Textual clock to be in sync with the OS's? I need to have the refresh to happen at the "exact" time the OS second changes (well, within a few ms, or close enough to not be humanly distinguishible).

---

_**Assistant**_

Looking at your clock implementation, I can see the issue. Currently, your clock updates every 1 second using `set_interval(1, self._show_time)`, but this doesn't guarantee synchronization with the OS's second boundary. The interval starts when the widget mounts, not necessarily at the start of a second.

Let me search for how this is typically handled in Textual applications and then provide a solution.


---

<details>
            <summary>Searched codebase "set_interval timer synchronization OS time boundary" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/appui/_clock.py` | L1-25 |
| `src/appui/stockyardapp_state.py` | L71-125 |
| `src/appui/stockyardapp_state.py` | L1-71 |
| `src/appui/_enums.py` | L21-28 |
| `src/appui/stockyardapp.py` | L89-136 |
| `src/appui/quote_table_state.py` | L439-485 |
| `src/yfinance/_yclient.py` | L127-156 |
| `src/appui/quote_table_state.py` | L485-518 |
| `src/appui/_footer.py` | L1-24 |
| `src/appui/quote_table_state.py` | L132-197 |
| `src/appui/quote_table_state.py` | L1-75 |
| `tests/appui/test_stockyardapp_state.py` | L105-117 |
| `src/appui/quote_table_state.py` | L75-132 |
| `src/appui/quote_table_state.py` | L197-258 |
| `src/appui/_quote_table.py` | L88-137 |
| `src/yfinance/_yclient.py` | L82-127 |
| `tests/appui/test_quote_table_state.py` | L67-85 |
| `src/yfinance/yquote.py` | L46-70 |
| `tests/appui/test_stockyardapp_state.py` | L160-188 |
| `tests/test_data.json` | L466-516 |
| `.github/workflows/check_yahoo_api.yml` | L1-43 |
| `src/appui/stockyardapp_state.py` | L125-141 |
| `tests/test_data.json` | L211-263 |
| `src/yfinance/_yclient.py` | L53-82 |
| `src/yfinance/_yclient.py` | L1-53 |

</details>

---

Now let me look at how Textual handles timers and intervals to understand the best approach for synchronization:


---

<details>
            <summary>Searched codebase "set_timer set_interval time synchronization exact second boundary" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/appui/_clock.py` | L1-25 |
| `src/appui/stockyardapp_state.py` | L71-125 |
| `src/appui/stockyardapp_state.py` | L1-71 |
| `src/yfinance/_yclient.py` | L127-156 |
| `src/appui/quote_table_state.py` | L439-485 |
| `src/appui/_enums.py` | L21-28 |
| `src/appui/quote_table_state.py` | L197-258 |
| `src/appui/stockyardapp.py` | L89-136 |
| `src/appui/quote_table_state.py` | L75-132 |
| `src/appui/quote_table_state.py` | L132-197 |
| `src/appui/quote_table_state.py` | L1-75 |
| `src/appui/_footer.py` | L1-24 |
| `src/appui/_quote_table.py` | L88-137 |
| `src/yfinance/_yclient.py` | L82-127 |
| `src/appui/quote_table_state.py` | L485-518 |
| `tests/appui/test_quote_table_state.py` | L67-85 |
| `src/yfinance/_yclient.py` | L311-346 |
| `src/yfinance/yquote.py` | L1339-1401 |
| `src/yfinance/_yclient.py` | L53-82 |
| `src/yfinance/_yclient.py` | L1-53 |
| `src/appui/stockyardapp.py` | L1-38 |
| `src/yfinance/yquote.py` | L1552-1591 |
| `src/appui/quote_table_state.py` | L258-297 |
| `src/yfinance/_yclient.py` | L248-311 |
| `src/yfinance/yquote.py` | L1475-1510 |

</details>

---

Perfect! I can see that the current implementation uses `set_interval(1, self._show_time)` which doesn't guarantee synchronization with the OS's second boundary. The solution is to calculate the delay until the next second boundary and use `set_timer` instead of `set_interval`.

Here's how to modify your clock to synchronize with the OS's second boundary:


---

```diff
  
  from datetime import datetime, timezone
+ from time import time
  
  from textual.widgets import Static
```

```diff
          # TODO Make the clock update on the system's second change
          self._show_time()
-         self.set_interval(
-             1,
-             self._show_time,
-         )
+         self._schedule_next_update()
+ 
+     def _schedule_next_update(self) -> None:
+         """Schedule the next update to occur at the next second boundary."""
+         
+         # Calculate time until next second boundary
+         now = time()
+         next_second = int(now) + 1
+         delay = next_second - now
+         
+         # Schedule the update
+         self.set_timer(delay, self._show_time_and_reschedule)
+ 
+     def _show_time_and_reschedule(self) -> None:
+         """Update the time and schedule the next update."""
+         
+         self._show_time()
+         self._schedule_next_update()
  
      def _show_time(self) -> None:
```

---

Now let's also update the TODO comment since we've implemented the synchronization:


---



---

Perfect! Now let's test the implementation to make sure it works correctly:


---



---



---

